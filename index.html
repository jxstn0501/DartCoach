<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>üèπ DartsCoach ‚Äì OCR, Dashboard & Trainingsplan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{
      --bg:#121212; --card:#1c1c1c; --ink:#eee; --muted:#bdbdbd; --brand:#ffcc00;
      --ok:#30d158; --err:#ff453a;
    }
    *{box-sizing:border-box}
    body{background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0}
    header{position:sticky;top:0;z-index:2;background:#161616;padding:14px 16px;border-bottom:1px solid #222;display:flex;gap:10px;align-items:center}
    header h1{margin:0;font-size:18px;color:var(--brand);font-weight:800}
    main{padding:16px;max-width:1000px;margin:0 auto}
    .card{background:var(--card);border:1px solid #242424;border-radius:14px;padding:16px;margin:12px 0;box-shadow:0 6px 20px rgba(0,0,0,.25)}
    h2{font-size:16px;margin:0 0 10px;font-weight:800}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .row>*{flex:1 1 280px}
    button{background:var(--brand);color:#000;border:none;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
    button.ghost{background:transparent;color:var(--brand);border:1px solid var(--brand)}
    .mono{white-space:pre-wrap;word-break:break-word;background:#111;border:1px solid #222;border-radius:10px;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
    .small{font-size:12px;color:var(--muted)}
    select,input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #2a2a2a;background:#111;color:#eee}

    /* Dashboard fixes */
    .chart-box{height:240px;position:relative}
    #roundTable{max-height:400px;overflow-y:auto;display:block;margin-top:10px}
    #roundTable table{width:100%;border-collapse:collapse}
    #roundTable th,#roundTable td{border:1px solid #2a2a2a;padding:6px;text-align:center}
    #roundTable th{background:#202020;position:sticky;top:0}
  </style>
</head>
<body>
<header>
  <h1>üèπ DartsCoach</h1>
</header>

<main>

  <!-- CONFIG -->
  <div class="card">
    <h2>üîë Konfiguration</h2>
    <div class="row">
      <div>
        <label class="small">OCR Backend (Cloud Run URL)</label>
        <input id="cfgOcrUrl" placeholder="https://...run.app/" />
      </div>
      <div>
        <label class="small">OpenAI API Key (gpt-4o-mini)</label>
        <input id="cfgOpenAI" placeholder="sk-..." />
      </div>
      <div>
        <label class="small">Notion API Key</label>
        <input id="cfgNotion" placeholder="secret_..." />
      </div>
      <div>
        <label class="small">Notion Database ID</label>
        <input id="cfgDb" placeholder="32-stellige-ID" />
      </div>
    </div>
    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="btnSaveCfg">Speichern</button>
      <button class="ghost" id="btnLoadCfg">Laden</button>
      <span id="cfgStatus" class="small"></span>
    </div>
    <p class="small" style="margin-top:8px">F√ºr ultraschnelles Test-Hosting nutze <b>Netlify Drop</b> (app.netlify.com/drop).</p>
  </div>

  <!-- OCR -->
  <div class="card">
    <h2>üì§ Screenshot importieren & OCR</h2>
    <div class="row">
      <div>
        <input type="file" id="fileInput" accept="image/*" />
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnOCR">OCR starten</button>
          <button class="ghost" id="btnClear">L√∂schen</button>
        </div>
        <div id="ocrStatus" class="small" style="margin-top:8px"></div>
      </div>
      <div>
        <div id="ocrText" class="mono" style="min-height:110px">OCR-Ergebnis erscheint hier‚Ä¶</div>
      </div>
    </div>
  </div>

  <!-- PLAYER PICKER -->
  <div class="card">
    <h2>üßë‚Äçü§ù‚Äçüßë Spieler</h2>
    <div class="row">
      <div>
        <label class="small">Spieler ausw√§hlen</label>
        <select id="playerSelect"></select>
      </div>
      <div style="align-self:flex-end">
        <button class="ghost" id="btnSwap">Reihenfolge tauschen</button>
      </div>
    </div>
    <div id="playerHint" class="small" style="margin-top:6px"></div>
  </div>

  <!-- DASHBOARD -->
  <div class="card">
    <h2>üìä Dashboard</h2>
    <div class="chart-box">
      <canvas id="scoreChart"></canvas>
    </div>
    <div id="roundTable"></div>
  </div>

  <!-- PLAN -->
  <div class="card">
    <h2>üéØ Trainingsplan</h2>
    <div class="row">
      <div>
        <button id="btnPlan">Trainingsplan (letzte 3‚Äì5 Runden)</button>
        <button class="ghost" id="btnNotion">Nach Notion speichern</button>
      </div>
    </div>
    <div id="planOut" class="mono" style="margin-top:10px;min-height:220px">Hier erscheint dein Trainingsplan‚Ä¶</div>
  </div>

</main>

<script>
/* ======================
   CONFIG & STORAGE
====================== */
const LS = { CFG:'dc_cfg', OCR:'dc_ocr', PARSED:'dc_parsed', ORDER:'dc_player_order' };

const CONFIG = {
  OCR_BACKEND: "https://visionnow-81553987588.europe-west1.run.app/",
  OPENAI_API_KEY: "",
  NOTION_API_KEY: "",
  NOTION_DATABASE_ID: ""
};

const $ = s => document.querySelector(s);
function saveLocal(k,v){ localStorage.setItem(k, JSON.stringify(v)); }
function loadLocal(k,def=null){ try{const v=localStorage.getItem(k); return v?JSON.parse(v):def;}catch{ return def; }}

/* ======================
   FILE & OCR
====================== */
function fileToBase64(file){
  return new Promise((resolve,reject)=>{
    const r=new FileReader();
    r.onload=()=>resolve(r.result.split(',')[1]);
    r.onerror=reject;
    r.readAsDataURL(file);
  });
}

async function runOCR(base64){
  const url = CONFIG.OCR_BACKEND;
  const res = await fetch(url, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body:JSON.stringify({ imageBase64: base64 })
  });
  const json = await res.json();
  if (json.error) throw new Error(json.error);
  return json?.textAnnotations?.[0]?.description
      || json?.fullTextAnnotation?.text
      || JSON.stringify(json,null,2);
}

/* ======================
   PARSER HELPERS
====================== */
function pointsOfToken(tok){
  const t=String(tok).toUpperCase().trim();
  if(/^T(\d{1,2})$/.test(t)) return 3*parseInt(t.slice(1),10);
  if(/^D(\d{1,2})$/.test(t)) return 2*parseInt(t.slice(1),10);
  if(/^(S)?(\d{1,2})$/.test(t)) return parseInt(t.replace('S',''),10);
  if(["BULL","DBULL","BULLSEYE","50"].includes(t)) return 50;
  if(["25","OBULL"].includes(t)) return 25;
  if(["MISS","0","-"].includes(t)) return 0;
  return NaN;
}
const validSingle = n => (n>=0 && n<=20) || n===25 || n===50;

// ‚Äû555‚Äú ‚Üí [5,5,5] ; ‚Äû212‚Äú ‚Üí [2,12] oder [21,2] (nur g√ºltige Singles)
function splitDigitsSmart(numStr){
  if(!/^\d{3}$/.test(numStr)) return [];
  // 555 ‚Üí 5,5,5
  if(/^(\d)\1\1$/.test(numStr)){
    const d = parseInt(numStr[0],10);
    return [[String(d),String(d),String(d)]];
  }
  const a = parseInt(numStr.slice(0,1),10), b = parseInt(numStr.slice(1),10);
  const c = parseInt(numStr.slice(0,2),10), d = parseInt(numStr.slice(2),10);
  const out = [];
  if(validSingle(a) && validSingle(b)) out.push([String(a), String(b)]);
  if(validSingle(c) && validSingle(d)) out.push([String(c), String(d)]);
  return out;
}

// baue genau 3 Darts; nutze expectedScore wenn vorhanden
function parseDartsSmart(line, expected){
  if(!line) return ["0","0","0"];
  let raw = (line.match(/\b(T\d{1,2}|D\d{1,2}|\d{1,3}|25|50|BULL|MISS)\b/ig) || []).map(t=>t.toUpperCase());
  // expand 3-stellige reine Zahlen smart
  let tokens = [];
  for(const tok of raw){
    if(/^\d{3}$/.test(tok)){
      const splits = splitDigitsSmart(tok);
      if(splits.length){ 
        // erst mal Platzhalter einsetzen, Entscheidung sp√§ter mit expected
        tokens.push({type:'split', variants:splits});
      } else {
        tokens.push({type:'num', val:tok});
      }
    } else {
      tokens.push({type:'lit', val:tok});
    }
  }

  // erzeuge Kandidaten-Listen (ersetzt 'split' durch alle Varianten)
  function expand(list, idx=0, acc=[]){
    if(idx===list.length) return [acc];
    const item = list[idx];
    if(item.type==='split'){
      let outs = [];
      for(const v of item.variants){
        outs = outs.concat(expand(list, idx+1, acc.concat(v)));
      }
      return outs;
    } else {
      return expand(list, idx+1, acc.concat([item.val]));
    }
  }
  let cands = expand(tokens);

  // auf exakt 3 Darts bringen
  cands = cands.map(arr=>{
    let out = arr.slice(0,3);
    while(out.length<3) out.push("0");
    return out;
  });

  // w√§hle beste Kandidaten: 1) exakte Summe zu expected, 2) sonst geringste ‚ÄûInvalidit√§t‚Äú + Summe nahe expected
  function invalidity(arr){
    // Zahlen >20 (au√üer 25/50) sind invalid
    let bad=0;
    for(const t of arr){
      if(/^\d+$/.test(t)){
        const n=parseInt(t,10);
        if(!validSingle(n)) bad+=1;
      }
    }
    return bad;
  }
  function sum(arr){ return arr.reduce((a,t)=>a+(pointsOfToken(t)||0),0); }

  let best = cands[0] || ["0","0","0"];
  let bestScore = { match:false, bad:999, diff:9999 };

  for(const cand of cands){
    const s = sum(cand);
    const bad = invalidity(cand);
    const diff = (typeof expected==='number') ? Math.abs(expected - s) : Math.abs(s); // ohne expected: nah an 0 (eher egal)
    const match = (typeof expected==='number') && (s===expected);
    const rank = {
      match,
      bad,
      diff
    };
    // Ranking: match > weniger bad > kleinere diff
    const better =
      (rank.match && !bestScore.match) ||
      (rank.match===bestScore.match && rank.bad < bestScore.bad) ||
      (rank.match===bestScore.match && rank.bad===bestScore.bad && rank.diff < bestScore.diff);
    if(better){ best=cand; bestScore=rank; }
  }
  return best;
}

/* ======================
   PARSER (Spielertrennung, Start/Ende)
====================== */
function parseAll(ocrText, startScore=501){
  const lines = ocrText.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

  // Spielernamen aus "HISTORIE <A>" + n√§chste Zeile als B
  let pA="Spieler A", pB="Spieler B";
  for(let i=0;i<lines.length;i++){
    const m = lines[i].match(/^HISTORIE\s+(.+)$/i);
    if(m){
      pA = m[1].trim();
      if(lines[i+1] && !/^RUNDE\s+\d+/i.test(lines[i+1]) && !/^\d/.test(lines[i+1])){
        pB = lines[i+1].trim();
      }
      break;
    }
  }

  const players = {[pA]:[], [pB]:[]};
  let startA=startScore, startB=startScore;

  for(let i=0;i<lines.length;i++){
    const m=lines[i].match(/^RUNDE\s+(\d+)/i);
    if(!m) continue;

    const round = parseInt(m[1],10);
    const block=[]; let j=i+1;
    while(j<lines.length && !/^RUNDE\s+\d+/i.test(lines[j])){ block.push(lines[j]); j++; }
    i=j-1;

    // potentiell angezeigte Rundenscores (nur Werte <=180 sind realistisch)
    const roundNums = block
      .filter(x=>/^\d{1,3}$/.test(x))
      .map(x=>parseInt(x,10))
      .filter(n=>n>=0 && n<=180);
    const expA = roundNums.length>=2 ? roundNums[roundNums.length-2] : null;
    const expB = roundNums.length>=2 ? roundNums[roundNums.length-1] : null;

    // Darts-Zeilen: letzte zwei ‚Äûdarts-√§hnlichen‚Äú Zeilen im Block
    const dartLines = block.filter(isDartLine);
    const lineA = dartLines[dartLines.length-2] || "";
    const lineB = dartLines[dartLines.length-1] || "";

    const dartsA = parseDartsSmart(lineA, expA);
    const dartsB = parseDartsSmart(lineB, expB);

    const scoreA = dartsA.reduce((a,t)=>a+(pointsOfToken(t)||0),0);
    const scoreB = dartsB.reduce((a,t)=>a+(pointsOfToken(t)||0),0);

    const bustText = block.join("\n");
    const bustA = /BUST/i.test(bustText) && scoreA===0;
    const bustB = /BUST/i.test(bustText) && scoreB===0;

    const endA = bustA ? startA : Math.max(startA - scoreA, 0);
    const endB = bustB ? startB : Math.max(startB - scoreB, 0);

    players[pA].push({ round, start:startA, darts:dartsA, score:scoreA, bust:bustA, end:endA });
    players[pB].push({ round, start:startB, darts:dartsB, score:scoreB, bust:bustB, end:endB });

    startA=endA; startB=endB;
  }

  return { players, order:[pA,pB] };
}

/* ======================
   RENDER
====================== */
let parsedAll=null, currentPlayer=null, chartRef=null, orderSwap=false;

function populatePlayers(){
  const sel=$("#playerSelect");
  sel.innerHTML="";
  const list = (orderSwap && parsedAll?.order) ? [...parsedAll.order].reverse() : parsedAll?.order || [];
  list.forEach(n=>{
    const opt=document.createElement('option'); opt.value=n; opt.textContent=n; sel.appendChild(opt);
  });
  currentPlayer = list[0] || null;
  $("#playerHint").textContent = list.length? `Reihenfolge: ${list.join(" ‚Ä¢ ")}` : "";
}

function renderDashboardFor(playerName){
  const rounds = parsedAll?.players?.[playerName] || [];
  const ctx=$("#scoreChart");
  if(chartRef) chartRef.destroy();
  chartRef = new Chart(ctx, {
    type:"line",
    data:{
      labels: rounds.map(r=>"R"+r.round),
      datasets:[{label:`Score ‚Äì ${playerName}`, data: rounds.map(r=>r.score)}]
    },
    options:{
      responsive:true, maintainAspectRatio:false,
      plugins:{ legend:{labels:{color:"#eee"}} },
      scales:{ x:{ticks:{color:"#eee"}}, y:{ticks:{color:"#eee"}} }
    }
  });

  let html = `<table><tr><th>Runde</th><th>Start</th><th>Darts</th><th>Score</th><th>Bust</th><th>Ende</th></tr>`;
  rounds.forEach(r=>{
    html += `<tr>
      <td>${r.round}</td>
      <td>${r.start}</td>
      <td>${r.darts.join(", ")}</td>
      <td>${r.score}</td>
      <td>${r.bust ? "‚úÖ" : "‚ùå"}</td>
      <td>${r.end}</td>
    </tr>`;
  });
  html += `</table>`;
  $("#roundTable").innerHTML = html;
}

/* ======================
   TRAININGSPLAN
====================== */
async function buildTrainingPlan(playerName){
  const rounds = parsedAll?.players?.[playerName] || [];
  const last = rounds.slice(-5); // 3‚Äì5; wir nehmen bis 5
  const today = new Date().toLocaleDateString('de-DE');

  const sys = "Du bist ein Darts-Coach. Du analysierst Rundendaten und erstellst einen fokussierten, umsetzbaren Trainingsplan.";
  const user = `Erstelle einen Trainingsplan im folgenden Layout (keine Tabellen, klare Abschnitte):
Trainingsplan f√ºr ${playerName} ‚Äì ${today}
Analyse
- Kurz & pr√§gnant basierend auf letzten ${last.length} Runden.
St√§rken ‚úÖ
- 2‚Äì3 Punkte
Schw√§chen ‚ö†Ô∏è
- 2‚Äì3 Punkte
Heutiger Trainingsplan üéØ
Abschnitts√ºberschrift | Dauer | Ziel | Begr√ºndung
- 3‚Äì5 √úbungen (z.B. Double Round the Clock, 121 Checkout Challenge, Scoring-Korridor usw.)
Abschluss: 1 Satz mentaler Tipp.

Daten (JSON):
${JSON.stringify(last, null, 2)}`;

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method:"POST",
    headers:{
      "Authorization":`Bearer ${CONFIG.OPENAI_API_KEY}`,
      "Content-Type":"application/json"
    },
    body:JSON.stringify({
      model:"gpt-4o-mini",
      messages:[
        {role:"system", content: sys},
        {role:"user", content: user}
      ],
      temperature:0.6
    })
  });
  const data = await res.json();
  if(!res.ok) throw new Error(data.error?.message || JSON.stringify(data));
  return data.choices?.[0]?.message?.content?.trim() || "Kein Plan erhalten.";
}

async function sendToNotion(planText, playerName){
  const title = `Trainingsplan f√ºr ${playerName} ‚Äì ${new Date().toLocaleDateString('de-DE')}`;
  const payload = {
    parent: { database_id: CONFIG.NOTION_DATABASE_ID },
    properties: {
      Name: { title: [{ text: { content: title } }] },
      Content: { rich_text: [{ type:"text", text:{ content: planText } }] }
    }
  };
  const res = await fetch("https://api.notion.com/v1/pages", {
    method:"POST",
    headers:{
      "Authorization":`Bearer ${CONFIG.NOTION_API_KEY}`,
      "Content-Type":"application/json",
      "Notion-Version":"2022-06-28"
    },
    body: JSON.stringify(payload)
  });
  if(!res.ok){
    const t = await res.text();
    throw new Error(t);
  }
  return await res.json();
}


window.addEventListener('DOMContentLoaded', ()=>{
  // load cfg
  const cfg = loadLocal(LS.CFG,{});
  CONFIG.OCR_BACKEND = cfg.OCR_BACKEND || CONFIG.OCR_BACKEND;
  CONFIG.OPENAI_API_KEY = cfg.OPENAI_API_KEY || "";
  CONFIG.NOTION_API_KEY = cfg.NOTION_API_KEY || "";
  CONFIG.NOTION_DATABASE_ID = cfg.NOTION_DATABASE_ID || "";

  $("#cfgOcrUrl").value = CONFIG.OCR_BACKEND;
  $("#cfgOpenAI").value = CONFIG.OPENAI_API_KEY;
  $("#cfgNotion").value = CONFIG.NOTION_API_KEY;
  $("#cfgDb").value = CONFIG.NOTION_DATABASE_ID;

  $("#btnSaveCfg").onclick = ()=>{
    CONFIG.OCR_BACKEND = $("#cfgOcrUrl").value.trim();
    CONFIG.OPENAI_API_KEY = $("#cfgOpenAI").value.trim();
    CONFIG.NOTION_API_KEY = $("#cfgNotion").value.trim();
    CONFIG.NOTION_DATABASE_ID = $("#cfgDb").value.trim();
    saveLocal(LS.CFG, {
      OCR_BACKEND:CONFIG.OCR_BACKEND,
      OPENAI_API_KEY:CONFIG.OPENAI_API_KEY,
      NOTION_API_KEY:CONFIG.NOTION_API_KEY,
      NOTION_DATABASE_ID:CONFIG.NOTION_DATABASE_ID
    });
    $("#cfgStatus").innerHTML = `<span class="ok">‚úì gespeichert</span>`;
  };
  $("#btnLoadCfg").onclick = ()=>{
    const c = loadLocal(LS.CFG,{});
    $("#cfgOcrUrl").value = c.OCR_BACKEND||"";
    $("#cfgOpenAI").value = c.OPENAI_API_KEY||"";
    $("#cfgNotion").value = c.NOTION_API_KEY||"";
    $("#cfgDb").value = c.NOTION_DATABASE_ID||"";
    $("#cfgStatus").innerHTML = `<span class="ok">‚úì geladen</span>`;
  };

  $("#btnOCR").onclick = async()=>{
    $("#ocrStatus").textContent = "‚è≥ OCR l√§uft‚Ä¶";
    const f = $("#fileInput").files?.[0];
    if(!f){ $("#ocrStatus").innerHTML=`<span class="err">Bitte Screenshot ausw√§hlen.</span>`; return; }
    try{
      const b64 = await fileToBase64(f);
      const text = await runOCR(b64);
      $("#ocrText").textContent = text;
      saveLocal(LS.OCR, text);

      parsedAll = parseAll(text, 501);
      saveLocal(LS.PARSED, parsedAll);

      populatePlayers();
      if(currentPlayer){ renderDashboardFor(currentPlayer); }
      $("#ocrStatus").innerHTML = `<span class="ok">‚úì OCR & Parse fertig</span>`;
    }catch(e){
      $("#ocrStatus").innerHTML = `<span class="err">Fehler: ${e.message}</span>`;
    }
  };

  $("#btnClear").onclick = ()=>{
    ["OCR","PARSED"].forEach(k=>localStorage.removeItem(LS[k]));
    $("#ocrText").textContent = "OCR-Ergebnis erscheint hier‚Ä¶";
    $("#roundTable").innerHTML = "";
    const canvas = $("#scoreChart");
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(chartRef) chartRef.destroy();
    $("#ocrStatus").textContent = "";
  };

  $("#playerSelect").onchange = (e)=>{
    currentPlayer = e.target.value;
    if(parsedAll) renderDashboardFor(currentPlayer);
  };

  $("#btnSwap").onclick = ()=>{
    orderSwap = !orderSwap;
    populatePlayers();
    if(currentPlayer) renderDashboardFor(currentPlayer);
    saveLocal(LS.ORDER, orderSwap);
  };

  // restore previous
  const prevText = loadLocal(LS.OCR,"");
  const prevParsed = loadLocal(LS.PARSED,null);
  const prevOrder = loadLocal(LS.ORDER,false);
  if(prevText){ $("#ocrText").textContent = prevText; }
  if(prevParsed){
    parsedAll = prevParsed; orderSwap = !!prevOrder;
    populatePlayers(); if(currentPlayer) renderDashboardFor(currentPlayer);
  }

  $("#btnPlan").onclick = async()=>{
    if(!parsedAll || !currentPlayer){ $("#planOut").textContent = "Keine Daten / kein Spieler gew√§hlt."; return; }
    $("#planOut").textContent = "‚è≥ Generiere Trainingsplan‚Ä¶";
    try{
      const plan = await buildTrainingPlan(currentPlayer);
      $("#planOut").textContent = plan;
    }catch(e){ $("#planOut").textContent = "Fehler: "+e.message; }
  };

  $("#btnNotion").onclick = async()=>{
    const txt = $("#planOut").textContent.trim();
    if(!txt){ alert("Kein Plan vorhanden."); return; }
    try{
      await sendToNotion(txt, currentPlayer || "Spieler");
      alert("‚úÖ Plan nach Notion gespeichert.");
    }catch(e){
      alert("Notion Fehler: "+e.message+"\n(Integration mit der Datenbank teilen & Property 'Content' existiert?)");
    }
  };
});

/* Global error pop */
window.onerror = (msg, src, line, col) => {
  alert("JS-Fehler: "+msg+" @"+line+":"+col);
};
</script>
</body>
</html>